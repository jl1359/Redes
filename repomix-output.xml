This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
package.json
README.md
src/core/pop3.ts
src/core/socket.ts
src/main.ts
src/parser/filter.ts
src/parser/mime.ts
src/utils
tests
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Dependencias (No se suben porque se instalan con npm install)
node_modules/

# Archivos de compilación (JavaScript generado)
dist/

# Archivos de entorno y logs
npm-debug.log*
.env

# Archivos del Sistema Operativo
.DS_Store
Thumbs.db

# Configuración de editores
.vscode/
.idea/
</file>

<file path="package.json">
{
    "name": "redes-pop3-client",
    "version": "1.0.0",
    "description": "Cliente POP3 seguro con filtro de adjuntos",
    "main": "dist/main.js",
    "scripts": {
        "start": "ts-node src/main.ts",
        "build": "tsc"
    },
    "keywords": [],
    "author": "",
    "license": "ISC",
    "devDependencies": {
        "@types/node": "^20.11.0",
        "ts-node": "^10.9.2",
        "typescript": "^5.3.3"
    }
}
</file>

<file path="README.md">
# Redes
trabajo-practico-de-redes-de-computadoras
</file>

<file path="src/core/pop3.ts">
import { SecureSocket } from './socket';
import { EmailFilter } from '../parser/filter';

export class POP3Client {
    private socket: SecureSocket;

    constructor() {
        this.socket = new SecureSocket();
    }

    async authenticate(host: string, user: string, pass: string) {
        const greeting = await this.socket.connect(host, 995);
        console.log('S:', greeting.trim());

        // Enviamos el usuario
        const userRes = await this.socket.sendCommand(`USER ${user}`);
        console.log('C: USER -> S:', userRes.trim());

        // Enviamos la contraseña
        const passRes = await this.socket.sendCommand(`PASS ${pass}`);
        console.log('C: PASS -> S:', passRes.trim());
        
        // Verificamos si la respuesta contiene "+OK" (sin importar mayúsculas/minúsculas)
        if (!passRes.toUpperCase().includes('+OK')) {
            throw new Error(`Credenciales incorrectas. Respuesta del servidor: ${passRes.trim()}`);
        }
        
        console.log('[Sistema] Autenticación exitosa en el servidor POP3');
    }

    async getStats(): Promise<number> {
        const res = await this.socket.sendCommand('STAT');
        return parseInt(res.split(' ')[1]);
    }

    async getSecureEmail(id: number) {
        const rawData = await this.socket.sendCommand(`RETR ${id}`);
        // Aplicamos el filtro de seguridad antes de devolver el correo
        return EmailFilter.processContent(rawData);
    }

    async quit() {
        await this.socket.sendCommand('QUIT');
        this.socket.close();
    }
}
</file>

<file path="src/core/socket.ts">
import * as tls from 'tls';

export class SecureSocket {
    private client?: tls.TLSSocket;

    connect(host: string, port: number): Promise<string> {
        return new Promise((resolve, reject) => {
            this.client = tls.connect(port, host, { rejectUnauthorized: false }, () => {
                console.log(`[Red] Conectado a ${host}:${port}`);
            });

            // Recibir el mensaje inicial del servidor (+OK)
            this.client.once('data', (data) => resolve(data.toString()));
            this.client.on('error', (err) => reject(err));
        });
    }

    sendCommand(command: string): Promise<string> {
        return new Promise((resolve, reject) => {
            if (!this.client) return reject("Socket no conectado");
            
            this.client.write(`${command}\r\n`);
            
            // Escuchar la respuesta del comando
            this.client.once('data', (data) => resolve(data.toString()));
        });
    }

    close() {
        this.client?.end();
    }
}
</file>

<file path="src/main.ts">
import { POP3Client } from './core/pop3';

async function main() {
    const client = new POP3Client();

    try {
        console.log("");
        console.log("   CLIENTE POP3 SEGURO - CLASE REDES      ");
        console.log("\n");

        // CONFIGURACIÓN:
        // Servidor: pop.gmail.com | Puerto: 995
        // RECUERDA: Usa una "Contraseña de Aplicación" de 16 letras de Google
        await client.authenticate('pop.gmail.com', 'jl1533336@gmail.com', 'sxaojqkacichirqh');

        const total = await client.getStats();
        console.log(`[Info] Mensajes totales en bandeja: ${total}`);

        if (total > 0) {
            console.log(`[Info] Analizando el último correo...\n`);
            
            // Obtenemos el último mensaje (índice total)
            const email = await client.getSecureEmail(total);

            console.log("");
            console.log(`ASUNTO: ${email.subject}`);
            console.log(`ADJUNTOS BLOQUEADOS: ${email.blockedCount}`);
            console.log("");
            console.log("CONTENIDO (Filtrado):");
            console.log(email.body.substring(0, 500) + "..."); 
            console.log("");
        } else {
            console.log("[!] La bandeja de entrada está vacía.");
        }

        await client.quit();
        console.log("\n[Sistema] Conexión cerrada correctamente.");

    } catch (error) {
        console.error("\n[Error Crítico]:", error);
    }
}

main();
</file>

<file path="src/parser/filter.ts">
export class EmailFilter {
    // Tipos de archivos que el ingeniero pidió bloquear
    private static BANNED_TYPES = [
        'application/pdf',
        'image/jpeg',
        'image/png',
        'image/gif'
    ];

    static processContent(rawEmail: string) {
        const lines = rawEmail.split('\n');
        let subject = "Sin Asunto";
        let body = "";
        let blockedCount = 0;
        let isInsideBannedAttachment = false;

        for (const line of lines) {
            const lowerLine = line.toLowerCase();

            // 1. Extraer el Asunto del correo
            if (lowerLine.startsWith('subject:')) {
                subject = line.substring(8).trim();
            }

            // 2. Detectar si la parte actual del mensaje es un adjunto prohibido
            if (lowerLine.includes('content-type:')) {
                const isBanned = this.BANNED_TYPES.some(type => lowerLine.includes(type));
                
                if (isBanned) {
                    isInsideBannedAttachment = true;
                    blockedCount++;
                    body += "\n[!] ARCHIVO ADJUNTO DETECTADO Y BLOQUEADO (Seguridad POP3)\n";
                    continue; 
                }
            }

            // 3. Si detectamos un "boundary" (separador MIME), reseteamos el bloqueo
            // Los adjuntos en correos terminan cuando aparece una línea que empieza con --
            if (line.startsWith('--')) {
                isInsideBannedAttachment = false;
            }

            // 4. Solo agregamos contenido al cuerpo si NO estamos dentro de un adjunto prohibido
            // También evitamos agregar las cabeceras técnicas al cuerpo legible
            if (!isInsideBannedAttachment && !lowerLine.startsWith('content-')) {
                body += line + "\n";
            }
        }

        return {
            subject,
            body: body.trim(),
            blockedCount
        };
    }
}
</file>

<file path="src/parser/mime.ts">

</file>

<file path="src/utils">

</file>

<file path="tests">

</file>

<file path="tsconfig.json">
{
    "compilerOptions": {
        "target": "ESNext",
        "module": "CommonJS",
        "rootDir": "./src",
        "outDir": "./dist",
        "esModuleInterop": true,
        "strict": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "include": ["src/**/*"]
}
</file>

</files>
