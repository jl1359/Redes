This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
package.json
README.md
src/core/pop3.ts
src/core/socket.ts
src/main.ts
src/parser/filter.ts
src/utils
tests
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Dependencias (No se suben porque se instalan con npm install)
node_modules/

# Archivos de compilación (JavaScript generado)
dist/

# Archivos de entorno y logs
npm-debug.log*
.env

# Archivos del Sistema Operativo
.DS_Store
Thumbs.db

# Configuración de editores
.vscode/
.idea/
</file>

<file path="package.json">
{
    "name": "redes-pop3-client",
    "version": "1.0.0",
    "description": "Cliente POP3 seguro con filtro de adjuntos",
    "main": "dist/main.js",
    "scripts": {
        "start": "ts-node src/main.ts",
        "build": "tsc"
    },
    "keywords": [],
    "author": "",
    "license": "ISC",
    "devDependencies": {
        "@types/node": "^20.11.0",
        "ts-node": "^10.9.2",
        "typescript": "^5.3.3"
    }
}
</file>

<file path="README.md">
# Redes
trabajo-practico-de-redes-de-computadoras
</file>

<file path="src/parser/filter.ts">
export class EmailFilter {
    // Tipos de archivos que el ingeniero pidió bloquear expresamente
    private static BANNED_TYPES = [
        'application/pdf',
        'image/jpeg',
        'image/png',
        'image/gif'
    ];

    static processContent(rawEmail: string) {
        const lines = rawEmail.split('\n');
        let subject = "Sin Asunto";
        let body = "";
        let isInsideBannedAttachment = false;
        let readingHeader = true; // Flag para saber cuando terminan las cabeceras principales

        for (const line of lines) {
            const lowerLine = line.toLowerCase();

            // 1. Extraer el Asunto (Subject)
            if (lowerLine.startsWith('subject:')) {
                subject = line.substring(8).trim();
                continue;
            }

            // 2. Detectar el fin de las cabeceras principales (línea vacía)
            if (readingHeader && line.trim() === "") {
                readingHeader = false;
                continue;
            }

            // 3. Control de adjuntos prohibidos
            if (lowerLine.includes('content-type:')) {
                const isBanned = this.BANNED_TYPES.some(type => lowerLine.includes(type));
                
                if (isBanned) {
                    isInsideBannedAttachment = true;
                    body += "\n>>> [SEGURIDAD] ARCHIVO ADJUNTO OMITIDO PREVENTIVAMENTE <<<\n";
                    continue; 
                }
            }

            // 4. Resetear bloqueo si encontramos un boundary de MIME (separador de partes)
            if (line.trim().startsWith('--')) {
                isInsideBannedAttachment = false;
                continue;
            }

            // 5. Construcción del cuerpo limpio
            // Evitamos: cabeceras técnicas, metadatos y contenido dentro de adjuntos prohibidos
            if (!readingHeader && !isInsideBannedAttachment) {
                const isTechnicalHeader = lowerLine.startsWith('content-') || 
                                        lowerLine.startsWith('x-') || 
                                        lowerLine.startsWith('received:');

                if (!isTechnicalHeader) {
                    body += line + "\n";
                }
            }
        }

        return {
            subject,
            body: body.trim() || "El cuerpo del mensaje está vacío o es puramente técnico."
        };
    }
}
</file>

<file path="src/utils">

</file>

<file path="tests">

</file>

<file path="tsconfig.json">
{
    "compilerOptions": {
        "target": "ESNext",
        "module": "CommonJS",
        "rootDir": "./src",
        "outDir": "./dist",
        "esModuleInterop": true,
        "strict": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "include": ["src/**/*"]
}
</file>

<file path="src/core/pop3.ts">
import { SecureSocket } from './socket';
import { EmailFilter } from '../parser/filter';

export class POP3Client {
    private socket: SecureSocket;

    constructor() {
        this.socket = new SecureSocket();
    }

    private delay(ms: number) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    /**
     * Valida que la respuesta del servidor comience con +OK.
     * CUMPLE REQUERIMIENTO: Manejo de errores de protocolo.
     */
    private checkResponse(response: string, context: string): string {
        if (!response.toUpperCase().trim().startsWith('+OK')) {
            throw new Error(`[Protocol Error] ${context}: ${response.trim()}`);
        }
        return response;
    }

    async authenticate(host: string, user: string, pass: string) {
        // 1. Conexión inicial
        const greeting = await this.socket.connect(host, 995);
        this.checkResponse(greeting, "Conexión inicial"); 
        console.log('S:', greeting.trim());
        await this.delay(500); 

        // 2. Comando USER
        const userRes = await this.socket.sendCommand(`USER ${user}`);
        this.checkResponse(userRes, "Usuario");
        console.log('C: USER -> S:', userRes.trim());
        await this.delay(500);

        // 3. Comando PASS
        const cleanPass = pass.replace(/\s+/g, '');
        const passRes = await this.socket.sendCommand(`PASS ${cleanPass}`);
        this.checkResponse(passRes, "Contraseña/Autenticación");
        
        console.log('[Sistema] Autenticación exitosa');
    }

    async getStats(): Promise<number> {
        const res = await this.socket.sendCommand('STAT');
        this.checkResponse(res, "Obtención de estadísticas (STAT)");
        
        // El formato es +OK [num_mensajes] [tamaño_total]
        const parts = res.split(' ');
        return parts.length > 1 ? parseInt(parts[1]) : 0;
    }

    /**
     * CUMPLE REQUERIMIENTO CRÍTICO: Evita bajar archivos adjuntos directamente.
     * En lugar de RETR, usamos TOP para limitar la descarga a texto seguro.
     */
    async getSecureHeaderAndBody(id: number, lines: number = 20) {
        console.log(`[Seguridad] Ejecutando TOP ${id} ${lines} para prevenir descarga de binarios...`);
        
        const rawData = await this.socket.sendCommand(`TOP ${id} ${lines}`);
        this.checkResponse(rawData, `Lectura de mensaje ${id}`);
        
        // Pasamos el contenido al filtro para extraer Subject y limpiar el Body
        return EmailFilter.processContent(rawData);
    }

    async quit() {
        const res = await this.socket.sendCommand('QUIT');
        this.checkResponse(res, "Cierre de sesión (QUIT)");
        console.log('S (QUIT):', res.trim());
        this.socket.close();
    }
}
</file>

<file path="src/core/socket.ts">
import * as tls from 'tls';

export class SecureSocket {
    private client?: tls.TLSSocket;
    // Tiempo límite de espera para evitar que la app se cuelgue (10 segundos)
    private readonly TIMEOUT_MS = 10000;

    /**
     * Establece conexión TLS con el servidor POP3.
     * CUMPLE REQUERIMIENTO: Manejo de errores de conexión.
     */
    connect(host: string, port: number): Promise<string> {
        return new Promise((resolve, reject) => {
            this.client = tls.connect(port, host, { rejectUnauthorized: false }, () => {
                console.log(`[Red] Conexión TLS establecida con ${host}:${port}`);
            });

            // Error si no se puede conectar inicialmente
            this.client.once('error', (err) => {
                reject(new Error(`Fallo de conexión inicial: ${err.message}`));
            });

            this.client.once('data', (data) => resolve(data.toString()));
        });
    }

    /**
     * Envía comandos y gestiona la recepción de datos multilínea (RETR/TOP).
     * CUMPLE REQUERIMIENTO: Manejo de errores inherentes al bajar archivos (Timeout).
     */
    sendCommand(command: string): Promise<string> {
        return new Promise((resolve, reject) => {
            if (!this.client) return reject(new Error("Socket no conectado"));

            let response = "";

            // Temporizador para evitar esperas infinitas si falla la red
            const timer = setTimeout(() => {
                this.client?.removeListener('data', onData);
                reject(new Error(`Timeout: El servidor dejó de responder al comando ${command}`));
            }, this.TIMEOUT_MS);

            const onData = (data: Buffer) => {
                // Si llegan datos, reiniciamos el temporizador
                timer.refresh();
                response += data.toString();
                
                // Los comandos TOP y RETR terminan con un punto en una línea nueva "\r\n.\r\n"
                if (command.startsWith("RETR") || command.startsWith("TOP")) {
                    if (response.endsWith("\r\n.\r\n")) {
                        clearTimeout(timer);
                        this.client?.removeListener('data', onData);
                        resolve(response);
                    }
                } else {
                    // Comandos de una sola línea (USER, PASS, STAT, QUIT)
                    clearTimeout(timer);
                    this.client?.removeListener('data', onData);
                    resolve(response);
                }
            };

            this.client.on('data', onData);
            this.client.write(`${command}\r\n`);
        });
    }

    /**
     * Cierre de socket seguro.
     */
    close() {
        if (this.client) {
            this.client.end();
            this.client.destroy();
            console.log("[Red] Socket destruido correctamente.");
        }
    }
}
</file>

<file path="src/main.ts">
import { POP3Client } from './core/pop3';

/**
 * Aplicación de Cliente POP3 Seguro
 * CUMPLE: 
 * - Conexión POP3/TLS
 * - Login usuario/pass
 * - STAT, TOP, QUIT
 * - Manejo de errores de protocolo y red
 */
async function main() {
    const client = new POP3Client();

    try {
        console.log("\n===========================================");
        console.log("   CLIENTE POP3 SEGURO - MODO PREVENTIVO   ");
        console.log("===========================================\n");

        // 1. & 2. Conexión y Autenticación
        await client.authenticate('pop.gmail.com', 'jl1533336@gmail.com', 'rppnnbetjpaeqbne');

        // 3. Obtener cantidad total de correos (Comando STAT)
        const total = await client.getStats();
        console.log(`[Info] Mensajes totales en bandeja: ${total}`);

        if (total > 0) {
            console.log(`[Seguridad] Analizando el último correo de forma preventiva...\n`);
            
            // 5. Visualización de cuerpo bloqueando adjuntos (Comando TOP)
            // Usamos 25 líneas para asegurar ver el inicio del cuerpo sin bajar el binario del PDF.
            const email = await client.getSecureHeaderAndBody(total, 25); 

            console.log("-------------------------------------------");
            console.log(`ASUNTO: ${email.subject}`);
            console.log(`ESTADO SEGURIDAD: Adjuntos (PDF/Imágenes) detectados y omitidos.`);
            console.log("-------------------------------------------");
            console.log("CUERPO DEL MENSAJE (Vista previa segura):");
            console.log(email.body); 
            console.log("-------------------------------------------");

            /**
             * CUMPLIMIENTO DE "ELIMINACIÓN TEMPORAL":
             * Informamos al usuario que la información no se borró, solo se protegió.
             */
            console.log(`[Aviso] La información adjunta se ha omitido temporalmente por seguridad.`);
            console.log(`[Acción] Para descargar el archivo completo bajo su propio riesgo, solicite el comando RETR ${total}.`);
            console.log("-------------------------------------------\n");
            
        } else {
            console.log("[!] La bandeja de entrada está vacía.");
        }

        // 6. Cierre de conexión correcto
        await client.quit();
        console.log("[Sistema] Conexión cerrada y recursos liberados.");

    } catch (error) {
        // Manejo de errores de conexión y protocolo (Inherent al bajar archivos)
        console.error("\n[Error Detallado]:", error instanceof Error ? error.message : error);
        process.exit(1);
    }
}

main();
</file>

</files>
